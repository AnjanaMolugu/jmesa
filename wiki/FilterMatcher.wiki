By default JMesa will filter your items. The items being the Collection of Beans or Collection of Maps. The JMesa filtering mechanism is very flexible and allows you to easily plug in your own filter strategy.

You plug in your filter strategy via the [TableFacade]. This allows you to set your own filter strategy via the !FilterMatcher interface. The !MatcherKey as you will see is how the proper !FilterMatcher object is found and invoked.

{{{
public void addFilterMatcher(MatcherKey key, FilterMatcher matcher);
}}}

We will start by looking at the !MatcherKey and !FilterMatcher in more depth, and then come back to how we add them to the [TableFacade].

The !MatcherKey is used to find the proper !FilterMatcher strategy. !MatcherKey is an immutable object that has two constructors. One takes only a class type, and the other takes a class type and property. This allows you to match filters either by a specific class type, or more specifically, by class type and for a given column property.

{{{
public class MatcherKey {
    public MatcherKey(Class type)

    public MatcherKey(Class type, String property)
}
}}}

However the actual work of whether or not an item is filtered is the work of the !FilterMatcher interface:

{{{
public interface FilterMatcher {
    public boolean evaluate(Object itemValue, String filterValue);
}
}}}

The itemValue is the current item value from the current Bean or Map in the Collection. The filterValue is the value entered by the user in the table filter. With these two pieces of information the !FilterMatcher will evaluate whether a match was or was not found.

As an example this is what the default string filter matcher looks like:
{{{
public class StringFilterMatcher implements FilterMatcher {
    public boolean evaluate(Object itemValue, String filterValue) {
        String item = StringUtils.lowerCase(String.valueOf(itemValue));
        String filter = StringUtils.lowerCase(String.valueOf(filterValue));
        if (StringUtils.contains(item, filter)) {
            return true;
        }

        return false;
    }
}
}}}

Then just add this to the [TableFacade].
{{{
tableFacade.addFilterMatcher(new MatcherKey(String.class), new StringFilterMatcher());
}}}

This is saying that all filters that represent a string class will be matched against the !StringFilterMatcher, which we now know is case-insensitive. Keep in mind that the (above) example is one of the defaults that is already set up for you. Hopefully by examining this one it should make sense on how you could easily come up with your own filtering strategy. 

Next lets looks at a slightly more complicated filter, the !DateFilterMatcher. *TODO:* Put in more complicated example.

=== UML Class Diagrams ===

==== The Filter class diagram. ====

http://extremecomponents.googlepages.com/filter.png



