The default way that JMesa deals with [Items items] is to take everything and then perform the filtering and sorting. The nice thing about this is you can get the filtering, sorting, and pagination for free. That works great for small to medium result sets, but starts to fail pretty miserably when the results are large. It really is a judgement call, but I prefer to let profiling make my technical decisions. If you are concerned that you have a performance problem then the best thing to do is put a profiler on it and see for yourself. There are many open source and commercial profilers available to help you make the best decision. So, lets assume that we have discovered a performance problem and need to deal with the pagination ourselves.

To handle the pagination manually means that you only pull back enough results to fit on one page. At the same time you will need to deal with the filtering, sorting and pagination yourself. For the following discussion I am assuming that you are getting the [Items items] from a database and not some other mechanism. Of course the same principles apply no matter what you do so you should easily be able to adapt your code.

Now here is the important part. To get a smaller result set you would create a query pulling data like normal, but limit the results that you get back. Every database has some command that allows you to limit the results retrieved from the database. For MySQL the command is limit, for Oracle it is between, for Sybase it is rowcount and for SQL Server it is top. If you are starting to follow my line of thinking what I am saying is when the user first goes to the table have the query only bring back the first page of result. If the user goes to the next page then return the next page of results.

The savy Sybase or SQL Server developer may be saying, but the rowcount command always starts at the beginning, so when I go to page two I have to start at the beginning. Well, yes, but now you have only returned two pages of results, as opposed to the whole result set. When you go to page three then you will only have pulled back three pages. Other databases, such as MySQL and Oracle, allow you to ask for a given section of rows so then you consistently only pull back the page that you need.

To find out how the user is trying to sort and filter, what page they are going to, and how many results they need to see JMesa has a convenient interface called the [Limit] and is pulled from the [TableFacade]: 

==== Example ====

The example uses JMesa, along with Spring and Hibernate (Criteria API). It also assumes you have already followed the [Setup setup] instructions.

For right now I will just forward you to the example 
[http://jmesa.googlecode.com/svn/trunk/jmesaWeb/src/org/jmesaweb/controller/LimitPresidentController.java limit controller]
implementation which is fairly well documented. As I get time I will offer more details on the wiki. Remember to pass the html contents to render the table on your [JSPExample web page]. Be sure to pay attention to the [Javascript] page link so that you understand how Javascript is used to interact with the table.

Remember that the !TableFacade interface also has setters for all the facade objects including the [WebContext], [CoreContext], [Limit], [Toolbar], and [View]. The reason is if you really need to customize something and want to set your own implementation you can. Your object just goes into the flow of the facade. For instance if you want a custom toolbar just set the Toolbar on the facade and when the render() method is called it will use your Toolbar.

_Once you have your table implemented you can use the !ParametersBuilder to [UnitTest test] your code.

You can see the 
[http://extremecomponents.org/jmesa/limit.run live example] on the site. If you do a view source on the site you will notice that the AJAX is drop dead simple. It uses the JMesa Javascript library to create the JMesa parameters, and the JQuery library for the AJAX call. In general this is the most elegant way to use JMesa as it does not require any additional work to create, and it avoids a full page refresh.

Note: the source code for this example, and all examples, are included in the jmesaWeb module checked into subversion. The site's data is run off of [http://hsqldb.org/ HSQLDB], which is an in-memory database. This makes it easy for anyone who wants to run the project to easily get it up and running. And, because the site only includes the code examples it is pretty easy to navigate the code.



