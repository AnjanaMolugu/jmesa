This page contains the new and noteworthy features for the JMesa 2.2 release. Be sure to also look at the [2_2_5NewAndNoteworthy 2.2.6 new and noteworthy] features.

This page also contains the changes that took place from the 2.1 to the 2.2 release. There are only a few changes that may effect some users, but for the most part the changes are transparent. Be sure to read about the deprecated and modified features to see if or what you may need to do.

_The images have been changed from .png files to .gif files and if you want the new look and feel you will need to update your jmesa.js and jmesa.css files. Also, JMesa is now using the [http://jquery.com jQuery] !JavaScript library. Your existing jmesa.js file does still work as expected, but if you want to use the new jmesa.js file you will need to include jQuery as well._

== Bugs Fixed ==
 * The tags were incorrectly creating new table, row and column objects each iteration over the tags. The reason is the !SimpleTagSupport class creates a new object each time they are used, so the local variables were being overwritten. I refactored this back to check and pull values directly from the table on the facade. In hindsight this was a much cleaner way to do it anyway as it keeps everything in the API. This is a performance fix as nothing functionally changed.
 * If had multiple tables on the same page then tables with no items would display the last row from the previous table. The reason was because the bean as defined by the var attribute was not being cleaned up in the page scope.
 * The State feature persists the current Limit. However, when doing exports this causes the problem of always wanting to export when restoring the State. The solution is if doing an export then will not persist the Limit for the export call. References  [http://code.google.com/p/jmesa/issues/detail?id=35&can=1 issue 35].
 * Toolbar rendering issue (missing title attribute for excel buton). The resource bundle had the incorrect syntax. It should be html.toolbar.tooltip.excel. References  [http://code.google.com/p/jmesa/issues/detail?id=37&can=1 issue 37].
 * Filter on Nullable Property. Fixed by looking at property attribute, and not column data. References [http://code.google.com/p/jmesa/issues/detail?id=36&can=1 issue 36].
 * The jmesa.js file had a bug that appeared when sorting multiple columns. The error was a result of bailing out of a .each loop incorrectly.
 * Fixed bug that appeared when clicking twice on an action in the toolbar (next page for example) and before the table reloads. The problem is when there is a double submission to the server the post parameters are duplicated.

=== Deprecated Features ===
 * Deprecated table.setCaption(key, message) in favor of table.setCaptionKey(key) to make the method to use with the Messages more clear and consistent with the tag library. The deprecated method will be removed in the next release.
 * Deprecated column.setTitle(key, message) in favor of column.setTitleKey(key) to make the method to use with the Messages more clear and consistent with the tag library. The deprecated method will be removed in the next release.
 * Deprecated the !HtmlHeaderRendererImpl.setDefaultSortOrderable() and !HtmlHeaderRendererImpl.isDefaultSortOrderable(). This has been replaced by the column sortOrder feature, which is much more flexible. The deprecated methods will be removed in the next release.

===== Column sortOrder =====
Set the sort order for the column. This restricts the sorting to only the types listed here. Typically you would use this to exclude the 'none' Order so that the user can only sort ascending and decending once invoked.

Note though that initially this does not change the look of the column, or effect the sorting, when the table is first displayed. For instance, if you only want to sort asc and then desc then when the table is initially displayed you need to make sure you set the Limit to be ordered. The reason is, by design, the limit does not look at the view for any information. The syntax to set the limit would be: limit.getSortSet().addSort();. If you do not do this then the effect will be that the once the column is sorted then it will just flip between asc and desc, which is still a really nice effect and is what I would mostly do.

In the API do this:

{{{
HtmlColumn htmlColumn = (HtmlColumn)firstName;
htmlColumn.setSortOrder(Order.ASC, Order.DESC);
}}}

The tag would look like this:
{{{
<jmesa:htmlColumn property="name.firstName" titleKey="presidents.firstName" sortOrder="asc,desc">
}}}

The legal Column sortOrder values are 'asc', 'desc', and 'none'.

=== Modified Features ===
 * Changed !ContextSupport to be an interface. I also further broke down the interface to extend from the !WebContextSupport and !CoreContextSupport interfaces which actually describe the methods. The reason I did this is so that classes that wanted the !ContextSupport feature would not have to extend a class. In hindsight this should have been done sooner. If you still want to extend a concrete class then extend !AbstractContextSupport.
 * The only !FilterMatcher registered by default now is the !StringFilterMatcher for all Object types (which means everything). The !DateFilterMatcher was removed as a default because it didn't make any sense to register a matcher with a hard coded date pattern. I am sure it was probably also confusing on why you would specify a new pattern and the filter did not work as expected. It was not clear that you also need to register a new !FilterMatcher so I thought it was better to just include the generic default. So, now if you want to filter a date column, and have it filter with a given pattern, you need to register a !DateFilterMatcher for either all dates, or that specific date property. See the [FilterMatcher] for more details.
 * In addition I removed the default date pattern for the !DateFilterMatcher and !DateCellEditor. There was no reason to default the date pattern to what I used.

=== New Features ===
 * Added an onclick, onmouseover, and onmouseout event handling for the row.
 * Added the ability to get at the original bean from an editor when using the tags.
 * Added a new !NumberCellEditor (contributed by jackcoll...@wallquest.com)
 * Added a new !NumberFilterMatcher class to allow for filtering columns that are using the !NumberCellEditor.
 * Further broke out the column header and filter to include an editor. This works exactly like the cell editor except tailored for the header and filter.
 * Added hooks for the tag library to register !FilterMatchers via the !FilterMatcherMap interface.
 * Added plugable views for the tag library.
 * Added a series of support interfaces for the tag library that will automatically inject certain objects into your custom classes. The interfaces just define getter and setter methods, but using these interfaces makes things very clear and safe. The idea is if you implement a certain interface the API will check for the inclusion of that interface and inject the class for you. This is really nice for the tag library because you would not have any other way to get at the objects you need. The support classes include !WebContextSupport, !CoreContextSupport, !ToolbarSupport, !TableSupport, !ColumnSupport and !PatternSupport.
 * !HtmlColumnsGenerator interface for the tag library to dynamically add columns at runtime.
 * New PDF View implementation (contributed by Paul Horn). The PDF is generated by using the [https://xhtmlrenderer.dev.java.net/ Flying Saucer] API.
  * You will need the pdf files included in the export-dependencies.zip (available in the downloads area of this site).
 * The State feature will look for the stateAttr in the request scope if it is not found in the parameters. This allows for more flexibility in various frameworks.
 * The exports will default to 'table-data._exportType_' if no caption is specified.
 * Switched to using .gif files instead of .png files as the default. The reason is .png files did not display correctly in IE. The .gif files are included in the distribution so just drag them into your project. I still included .png files as those are easier to customize. If you want to still use the .png files in your project then you can override the defaults in your [Preferences] file.
 * Improved look and feel for filter. Now very subtle effect. 
  * The look and feel changes require an updated jmesa.js and jmesa.css files. In addition with the new jmesa.js file you will need to start using the jQuery library as I utilized that heavily. You can get that at the jQuery [http://jquery.com homepage].
 * Drop Shadow option for table, which gives a nice aesthetic effect (preview above).
  * To make it work put the following script in your code to execute when the page is loaded. Here the imagesPath is the path to your images directory. The following imagesPath in the JMesa web site resolves to '/jmesa/images/table'
  * Also include the following images
   * shadow_back.gif
   * shadow180.gif
   * shadow.gif
   * corner_tr.gif
   * corner_bl.gif

{{{
<script type="text/javascript">
	$(document).ready(function() {
	   addDropShadow('${imagesPath}');
	});
</script>
}}}

 * The following Locales are added:
  * Dutch (nl_NL) (contributed by Tom Kalmijn and Marco de Booy)
  * Spanish (es_MX) (contributed by Jes√∫s Morones)

 * Added a getBytes() method on the View to make testing exports easier.
 * Passing in the action invoked string now as the second parameter on the !JavaScript. Could be very useful in custom circumstances. Like any !JavaScript method this additional parameter is optional.

For example this is a custom handling of the sorting that overrides the default behavior and to only allow one column to be sorted at a time.
{{{
function onInvokeAction(id, action) {
    setExportToLimit(id, '');

    if (action == 'sort') {
        var limit = LimitManager.getLimit(id);
        var sortSet = limit.getSortSet();
        if (sortSet) {
            var sort = limit.sortSet[limit.sortSet.length - 1];
            removeAllSortsFromLimit(id)
            limit.sortSet[0] = sort;
        }
    }
	createHiddenInputFieldsForLimitAndSubmit(id);
}
}}}

===== Column Onclick Event =====
The onclick event on the row:

{{{
public String onclick(RowEvent event);
}}}

The !RowEvent is a callback interface:

{{{
public interface RowEvent {
   public String execute(Object item, int rowcount);

}
}}}

This allows custom onclick callback events for each row:

{{{
HtmlRow row = table.getRow();
row.setOnclick(new RowEvent() {
      public String execute(Object Item, int rowcount) {
           // do something custom for each click on the row
          //  which contains data from the item.
      }

};)
}}} 

The tag looks like this:
{{{
<jmesa:htmlRow onclick="org.jmesaweb.controller.TagRowEvent">
}}}

{{{
public class TagRowEvent implements RowEvent {
    public String execute(Object item, int rowcount) {
        Object bean = ItemUtils.getItemValue(item, "bean");
        Object id = ItemUtils.getItemValue(bean, "id");
        return "document.location='http://www.whitehouse.gov/history/presidents?id=" + id + "'";
    }
}
}}}

_The onmouseover and onmouseout work the same way._

===== Tags bean value =====
Currently when using the tag library under the hood the item is swapped out for a Map for each row. Because JMesa works with beans and maps completely transparently this works really well and is completely transparent. However, the map will only contain the values for the columns defined, and not the other values from the original bean. Now the original bean can be recovered from the map in the editor. The bean can be recovered from the map by the !TableFacadeTag var attribute.

For example if the tableFacade looks like this:
{{{
<jmesa:tableFacade
   id="tag" 
   ...
   var="bean"
>
}}}

Notice how the original item can be recovered by the var attribute! It is recommended that you use the !ItemUtils because that abstracts out whether or not the item is a bean or a map, which is perfect for this.

{{{
public class TagRowEvent implements RowEvent {
    public String execute(Object item, int rowcount) {
        Object bean = ItemUtils.getItemValue(item, "bean");
        Object id = ItemUtils.getItemValue(bean, "id");
        return "document.location='http://www.whitehouse.gov/history/presidents?id=" + id + "'";
    }
}
}}}

===== !HeaderEditor =====
The header now has an editor to break out the logic of what the header looks like and what  kind of element it is.

For instance if you wanted to have a header that displayed a checkbox you would do this:
{{{
HtmlColumn htmlColumn = (HtmlColumn)lastName;
htmlColumn.getHeaderRenderer().setHeaderEditor(new HeaderEditor() {
    public Object getValue() {
        return "<input type=\"checkbox\">";
    }
});
}}}

The tag would look like this:
{{{
headerEditor="org.jmesaweb.controller.TagHeaderEditor" 
}}}

===== !FilterEditor =====
The filter now has an editor to break out the logic of what the filter looks like and what  kind of element it is.

If you wanted to have a filter that displayed a select element you would do this:
{{{
HtmlColumn careerColumn = (HtmlColumn)row.getColumn("career");;
careerColumn.getFilterRenderer().setFilterEditor(new FilterEditor() {
    public Object getValue() {
        return "<select><option value=\"career\">Career</option><option value=\"lawyer\">Lawyer</option></select>";
    }
});
}}}

The tag would look like this:
{{{
filterEditor="org.jmesaweb.controller.TagFilterEditor"
}}}


Note though that for this filter example you would still need to add the Javascript to interact with the Javascript Limit. If this is something you are interested in you can look at the !HtmlFilterEditor to see the default example.

===== filterMatcherMap (for tag library) =====
If you have a column that uses a special editor such as the !DateCellEditor and you want to have the JMesa API filter the results you will need to register custom !FilterMatchers. With the tag library you would do this through the filterMatcherMap attribute. 

For instance if you have a column that looks like this:
{{{
<jmesa:htmlColumn property="born" pattern="MM/yyyy" cellEditor="org.jmesa.view.editor.DateCellEditor"/>
}}}

You now need to set up a custom !FilterMatcherMap.

{{{
public class TagFilterMatcherMap implements FilterMatcherMap {
    public Map<MatcherKey, FilterMatcher> getFilterMatchers() {
        Map<MatcherKey, FilterMatcher> filterMatcherMap = new HashMap<MatcherKey, FilterMatcher>();
        filterMatcherMap.put(new MatcherKey(Date.class, "born"), new DateFilterMatcher("MM/yyyy"));
        filterMatcherMap.put(new MatcherKey(Number.class, "id"), new NumberFilterMatcher("$##0.00"));
        return filterMatcherMap;
    }
}
}}}

Just make sure you define the filterMatcherMap on the !TableFacadeTag:
{{{
<jmesa:tableFacade
        id="tag" 
        filterMatcherMap="org.jmesaweb.controller.TagFilterMatcherMap"
}}}

_For more information about the filter matchers see the [FilterMatcher] page._

===== !FilterMatcherMap in API =====
I added the !FilterMatcherMap to the !TableFacade interface. The !FilterMatcherMap is generally used for the tag library to set the filter matchers. By adding this to the !TableFacade it means you can use the same object for the exports. You could also use this for the general API if desired.

{{{
tableFacade.addFilterMatcherMap(new TagFilterMatcherMap());
}}}

===== !HtmlColumnsGenerator (for tag library) =====
There is a new tag called the !HtmlColumnsTag. It contains one variable called htmlColumnsGenerator.

{{{
<jmesa:htmlColumns htmlColumnsGenerator="org.jmesaweb.controller.TagHtmlColumnsGenerator"/>
}}}

It corresponds with the !HtmlColumnsGenerator interface and is used so that you can add columns on the fly.

{{{
public interface HtmlColumnsGenerator {
    public List<HtmlColumn> getColumns(HtmlComponentFactory componentFactory);
}
}}}

An example is:

{{{
public class TagHtmlColumnsGenerator extends AbstractContextSupport implements HtmlColumnsGenerator {
    public List<HtmlColumn> getColumns(HtmlComponentFactory componentFactory) {
        List<HtmlColumn> columns = new ArrayList<HtmlColumn>();

        HtmlColumn firstName = componentFactory.createColumn("name.firstName");
        firstName.setTitle("First Name");
        columns.add(firstName);

        HtmlColumn lastName = componentFactory.createColumn("name.lastName");
        lastName.setTitle("Last Name");
        columns.add(lastName);

        HtmlColumn born = componentFactory.createColumn("born");
        columns.add(born);

        return columns;
    }
}
}}}

===== !ComponentFactory in API =====
One really nice side effect of the !HtmlColumnsGenerator is I was asked if there was a similar way to create tables and exports in the API. There always was, but I abstracted it away on the facade. Now I opened up the API so that you can set tables on the facade and then use the !ComponentFactory to create tables. This technique is completely optional but may be nice in some situations, or you may decide this is a more natural way to create tables.

All you have to do is use one of the new constructors on the !TableFacadeImpl in which you do not declare the columns, and then set the table on the facade.

{{{
TableFacade tableFacade = new TableFacadeImpl(id, request, maxItems, items);

HtmlComponentFactory factory = new HtmlComponentFactory(tableFacade.getWebContext(), tableFacade.getCoreContext());

HtmlTable table = factory.createTable();

HtmlRow row = factory.createRow();
row.addColumn(factory.createColumn("name.firstName"));
row.addColumn(factory.createColumn("name.lastName"));
row.addColumn(factory.createColumn("term"));

HtmlColumn career = factory.createColumn("career");
career.setFilterable(false);
row.addColumn(career);

table.setRow(row); // be sure to set the row on the table

tableFacade.setTable(table);
}}}

Or, for the exports you could do this:

{{{
TableFacade tableFacade = new TableFacadeImpl(id, request, items); // do not need maxItems for exports
tableFacade.setExportTypes(response, "excel");

Limit limit = tableFacade.getLimit();

if (limit.isExportable()) {

    if (limit.getExport().getType().equals("excel")) {
        ExcelComponentFactory factory = new ExcelComponentFactory(tableFacade.getWebContext(), tableFacade.getCoreContext());

        Table table = factory.createTable();

        Row row = factory.createRow();
        row.addColumn(factory.createColumn("name.firstName"));
        row.addColumn(factory.createColumn("name.lastName"));
        row.addColumn(factory.createColumn("term"));
        row.addColumn(factory.createColumn("career"));

        table.setRow(row); // be sure to set the row on the table

        tableFacade.setTable(table);
    }
    
}
}}}

=== Tag Attributes Implemented ===
The following is a list of attributes that exists on the core API and needed to be implemented with the tags.

==== !TableFacadeTag ====
|| *Attribute*||
|| messages ||
|| preferences ||
|| columnSort ||
|| rowFilter ||
|| toolbar ||

==== !HtmlTableTag ====
|| *Attribute* ||
|| tableRenderer ||

==== !HtmlRowTag ====
|| *Attribute* ||
|| rowRenderer ||
|| style ||
|| styleClass ||
|| evenClass ||
|| oddClass ||
|| highlightStyle ||
|| highlightClass ||

==== !HtmlColumnTag ====
|| *Attribute* ||
|| style ||
|| styleClass ||
|| cellRenderer ||
|| filterRenderer ||
|| headerRenderer ||
|| headerStyle ||
|| headerClass ||
|| filterStyle ||
|| filterClass ||