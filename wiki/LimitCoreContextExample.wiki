In this example we are doing the filtering and sorting in the database. The main points of interest as compared to the simple way of working with the Limit is in the way that we have to actively find the total rows and use the filtering and sorting. You will also notice that the [Limit] and [CoreContext] are created in the same method. This still works because the Limit is available on the !CoreContext and can be easily retrieved.

==== Example ====

Create the Limit like normal.
{{{
LimitFactory limitFactory = new LimitFactoryImpl(id, webContext);
Limit limit = limitFactory.createLimit();
}}}

Convert the Limit filter and sort objects to something the service prefers to work with. I took this a step further and have the !PresidentFilter and !PresidentSort build up a Hibernate Criteria object.
{{{
PresidentFilter presidentFilter = getPresidentFilter(limit);
PresidentSort presidentSort = getPresidentSort(limit);
}}}

Figure out the total rows. This is necessary because we are only returning one page of data, but the table still needs to know how many results were possible. The total rows only needs to know about what was filtered, not sorted. The filtering effects the total amount of rows, the sorting does not.
{{{
int totalRows = presidentService.getPresidentsCountWithFilter(presidentFilter);
}}}

Write a little boilerplate code to set the !RowSelect on the Limit. Notice how for exports we need to create the !RowSelect manually. This is because the factory takes in account that the max rows may be changed by the user on the table. When exporting we want to show the results regardless of the pagination.
{{{
if (limit.isExportable()) {
    RowSelect rowSelect = new RowSelectImpl(1, totalRows, totalRows);
    limit.setRowSelect(rowSelect);
} else {
    RowSelect rowSelect = limitFactory.createRowSelect(maxRows, totalRows);
    limit.setRowSelect(rowSelect);
}
}}}

Call the pagination logic. By using the filtering, sorting and row information we are able to help the database return one page of data.
{{{
int rowStart = limit.getRowSelect().getRowStart();
int rowEnd = limit.getRowSelect().getRowEnd();
Collection<Object> items = presidentService.getPresidentsWithFilterAndSort(presidentFilter, presidentSort, rowStart, rowEnd);
}}}

Finally create the !CoreContext. The thing to notice here is that we are setting the first parameter on the !CoreContextFactory to false. This variable is called performFilterAndSort and lets the factory know whether or not it needs to perform the filtering and sorting. Because we off-loaded this work to the database already we do not need to do it again. 
{{{
CoreContextFactory factory = new CoreContextFactoryImpl(false, webContext);
CoreContext coreContext = factory.createCoreContext(items, limit);
}}}



===== Full Example =====

{{{
public CoreContext getCoreContext(WebContext webContext) {
    LimitFactory limitFactory = new LimitFactoryImpl(id, webContext);
    Limit limit = limitFactory.createLimit();

    PresidentFilter presidentFilter = getPresidentFilter(limit);
    PresidentSort presidentSort = getPresidentSort(limit);

    int totalRows = presidentService.getPresidentsCountWithFilter(presidentFilter);

    if (limit.isExportable()) {
        RowSelect rowSelect = new RowSelectImpl(1, totalRows, totalRows);
        limit.setRowSelect(rowSelect);
    } else {
        RowSelect rowSelect = limitFactory.createRowSelect(maxRows, totalRows);
        limit.setRowSelect(rowSelect);
    }

    int rowStart = limit.getRowSelect().getRowStart();
    int rowEnd = limit.getRowSelect().getRowEnd();

    Collection<Object> items = presidentService.getPresidentsWithFilterAndSort(presidentFilter, presidentSort, rowStart, rowEnd);

    CoreContextFactory factory = new CoreContextFactoryImpl(webContext);
    return factory.createCoreContext(items, limit);
}
}}}


{{{
protected PresidentFilter getPresidentFilter(Limit limit) {
    PresidentFilter presidentFilter = new PresidentFilter();
    FilterSet filterSet = limit.getFilterSet();
    Collection<Filter> filters = filterSet.getFilters();
    for (Filter filter : filters) {
        String property = filter.getProperty();
        String value = filter.getValue();
        presidentFilter.addFilter(property, value);
    }

    return presidentFilter;
}
}}}


{{{
protected PresidentSort getPresidentSort(Limit limit) {
    PresidentSort presidentSort = new PresidentSort();
    SortSet sortSet = limit.getSortSet();
    Collection<Sort> sorts = sortSet.getSorts();
    for (Sort sort : sorts) {
        String property = sort.getProperty();
        String order = sort.getOrder().toParam();
        presidentSort.addSort(property, order);
    }

    return presidentSort;
}
}}}















