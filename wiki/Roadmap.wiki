===== 2/27/2007 =====
The road map for JMesa is still being defined. However, the general plan is to start with the release candidates as soon as the documentation is more complete. I would also like to get some more unit tests and examples done. I fully expect to have the documentation, unit tests and enough examples done by the end of March. It is undefined as to how many release candidates we will need, but the idea would be to encourage more people to try out the library before going to a final release.

===== 4/1/2007 =====
The release candidates have started. If all goes well the production release will be out by mid-April.

===== 4/18/2007 =====
The 2.0 release is out!

==== version 2.1, August 13, 2007 ====
An Excel View, using Apache POI, is implemented and will be available in the next release. That was contributed by jeff jie! Another contribution by jeff jie was the start of a [Tags tag library]. What I would like to do is clean up a few things with the current implementation and then release that code as soon as possible. The tag library will have the basic functionality required by most developers. Future releases will make use of more advanced API features. And, lastly there is a new [TableFacade] interface that makes working with the API much easier.

==== version 2.2, (September 2007) ====
The new features include the following:
 * Add an onclick, onmouseover, and onmouseout event enhancement for the row. _(done)_
 * Add a column sortOrder. This takes a comma separated list of values to say how you want the column to be sorted. _(done)_
 * Further broke out the column header and filter to include an editor. This works exactly like the cell editor except tailored for the header and filter. _(done)_
 * The ability to get at the original bean from an editor when using the tags. _(done)_
 * A new !NumberCellEditor (contributed by jackcoll...@wallquest.com) _(done)_
 * Changed !ContextSupport to be an interface. The implementing class is called !AbstractContextSupport. This is so that if an editor referenced from a tag did not want to extend a class to get !ContextSupport it could. In hindsight this should have been done sooner. In that same way of thinking there are two other new interfaces called !PatternSupport and !ColumnSupport so that editors that want to get a pattern or column injected in them have a safe way to do that. I will explain this feature more later if that does not make complete sense. _(done)_
 * Deprecated table.setCaption(key, message) in favor of table.setCaptionKey(key) to make the method to use with the Messages more clear and consistent with the tag library. _(done)_
 * Deprecated column.setTitle(key, message) in favor of column.setTitleKey(key) to make the method to use with the Messages more clear and consistent with the tag library. _(done)_
 * Added hooks for the tag library to register !FilterMatchers. _(done)_
 * Plugable views for the tag library. _(done)_

===== Column Onclick Event =====
The onclick event on the row would be something like this:

public String onclick(!RowEvent event);

The !RowEvent would be a callback interface:

{{{
public interface RowEvent {
   public String execute(Object item, int rowcount);

}
}}}

This would allow custom onclick callback events for each row.

{{{
HtmlRow row = table.getRow();
row.setOnclick(new RowEvent() {
      public String execute(Object Item, int rowcount) {
           // do something custom for each click on the row
          //  which contains data from the item.
      }

};)
}}} 

The tag would look like this:
{{{
<jmesa:htmlRow onclick="org.jmesaweb.controller.TagRowEvent">
}}}

{{{
public class TagRowEvent implements RowEvent {
    public String execute(Object item, int rowcount) {
        Object bean = ItemUtils.getItemValue(item, "bean");
        Object id = ItemUtils.getItemValue(bean, "id");
        return "document.location='http://www.whitehouse.gov/history/presidents?id=" + id + "'";
    }
}
}}}

===== Column sortOrder =====
Set the sort order for the column. This restricts the sorting to only the types listed here. Typically you would use this to exclude the 'none' Order so that the user can only sort ascending and decending once invoked.

Note though that initially this does not change the look of the column, or effect the sorting, when the table is first displayed. For instance, if you only want to sort asc and then desc then when the table is initially displayed you need to make sure you set the Limit to be ordered. The reason is, by design, the limit does not look at the view for any information. The syntax to set the limit would be: limit.getSortSet().addSort();. If you do not do this then the effect will be that the once the column is sorted then it will just flip between asc and desc, which is still a really nice effect and is what I would mostly do.

In the API do this:

{{{
HtmlColumn htmlColumn = (HtmlColumn)firstName;
htmlColumn.setSortOrder(Order.ASC, Order.DESC);
}}}

The tag would look like this:
{{{
<jmesa:htmlColumn property="name.firstName" titleKey="presidents.firstName" sortOrder="asc,desc">
}}}

===== Tags bean value =====
Currently when using the tag library under the hood the item is swapped out for a Map for each row. Because JMesa works with beans and maps completely transparently this works really well and is completely transparent. However, the map will only contain the values for the columns defined, and not the other values from the original bean. Now the original bean can be recovered from the map in the editor. The bean can be recovered from the map by the !TableFacadeTag var attribute.

For example if the tableFacade looks like this:
{{{
<jmesa:tableFacade
   id="tag" 
   ...
   var="bean"
>
}}}

Notice how the original item can be recovered by the var attribute! It is recommended that you use the !ItemUtils because that abstracts out whether or not the item is a bean or a map, which is perfect for this.

{{{
public class TagRowEvent implements RowEvent {
    public String execute(Object item, int rowcount) {
        Object bean = ItemUtils.getItemValue(item, "bean");
        Object id = ItemUtils.getItemValue(bean, "id");
        return "document.location='http://www.whitehouse.gov/history/presidents?id=" + id + "'";
    }
}
}}}

===== !HeaderEditor =====
The header now has an editor to break out the logic of what the header looks like and what  kind of element it is.

For instance if you wanted to have a header that displayed a checkbox you would do this:
{{{
HtmlColumn htmlColumn = (HtmlColumn)lastName;
htmlColumn.getHeaderRenderer().setHeaderEditor(new HeaderEditor() {
    public Object getValue() {
        return "<input type=\"checkbox\">";
    }
});
}}}

The tag would look like this:
{{{
headerEditor="org.jmesaweb.controller.TagHeaderEditor" 
}}}

===== !FilterEditor =====
The filter now has an editor to break out the logic of what the filter looks like and what  kind of element it is.

If you wanted to have a filter that displayed a select element you would do this:
{{{
HtmlColumn careerColumn = (HtmlColumn)row.getColumn("career");;
careerColumn.getFilterRenderer().setFilterEditor(new FilterEditor() {
    public Object getValue() {
        return "<select><option value=\"career\">Career</option><option value=\"lawyer\">Lawyer</option></select>";
    }
});
}}}

The tag would look like this:
{{{
filterEditor="org.jmesaweb.controller.TagFilterEditor"
}}}


Note though that for this filter example you would still need to add the Javascript to interact with the Javascript Limit. If this is something you are interested in you can look at the !HtmlFilterEditor to see the default example.

===== filterMatcherMap (for tag library) =====
If you have a column that uses a special editor such as the !DateCellEditor and you want to have the JMesa API filter the results you will need to register custom !FilterMatchers. With the tag library you would do this through the filterMatcherMap attribute. 

For instance if you have a column that looks like this:
{{{
<jmesa:htmlColumn property="born" pattern="MM/yyyy" cellEditor="org.jmesa.view.editor.DateCellEditor"/>
}}}

You now need to set up a custom !FilterMatcherMap.

{{{
public class TagFilterMatcherMap implements FilterMatcherMap {
    public Map<MatcherKey, FilterMatcher> getFilterMatchers() {
        Map<MatcherKey, FilterMatcher> filterMatcherMap = new HashMap<MatcherKey, FilterMatcher>();
        filterMatcherMap.put(new MatcherKey(Date.class, "born"), new DateFilterMatcher("MM/yyyy"));
        filterMatcherMap.put(new MatcherKey(Number.class, "id"), new NumberFilterMatcher("$##0.00"));
        return filterMatcherMap;
    }
}
}}}

Just make sure you define the filterMatcherMap on the !TableFacadeTag:
{{{
<jmesa:tableFacade
        id="tag" 
        filterMatcherMap="org.jmesaweb.controller.TagFilterMatcherMap"
}}}

_For more information about the filter matchers see the [FilterMatcher] page._

==== Future Release ====

I am also trying to find out what developers are interested in for future releases. If you have any suggestions be sure to reply to the post on [http://groups.google.com/group/jmesa/browse_thread/thread/45ca5716dcd9bb7f Google Groups].

In the next few months JMesa is going to have an editable mode. The editable mode will work something like the Google spreadsheet in that when you click on a column a div will pop up and you enter your data there. Then I will look for an onchange event. The server will then make a map for each row that changed. Something like that. I still need to map out the details and make concrete decisions. Like everything else I want to take quite a bit of time to design the whole thing up front.


















