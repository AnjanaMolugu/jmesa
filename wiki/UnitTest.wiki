JMesa can easily be unit tested. By using the Parameters interface combined with the !ParametersBuilder class you can easily throw JMesa into any state you want.

The !ParametersBuilder abstracts out the parameters that allows you to set up the table. The following method calls are available:

{{{
public class ParametersBuilder {
    public void setPage(int page) {}

    public void setMaxRows(int maxRows) {}

    public void addFilter(String property, String value) {}

    public void addSort(String property, Order order) {}
    
    public void addSort(int position, String property, Order order) {}

    public void setExport(String exportType) {}
}
}}}

This should be pretty straightforward. You can easily set the page, max rows and export. In addition you can add filter or sort objects. However, you might still be wondering how this actually sets the parameters on the (mock) request. For that to happen you need to set the Parameters (interface) on the !ParametersBuilder constructor. 

Right now there are two implementations to set up the Parameters. One if you are using the Spring framework, and the other if you are setting the parameters on the !WebContext manually.

==== SpringParametersAdapter Example ====

If you are using Spring you will want to set up the parameters by using the !SpringParametersAdapter. The following example shows how you would use the Spring !MockHttpServletRequest with the !SpringParametersAdapter to make the !ParametersBuilder work.

{{{
MockHttpServletRequest request = new MockHttpServletRequest();
Parameters parameters = new SpringParametersAdapter(request);
ParametersBuilder builder = new ParametersBuilder(ID, parameters);
}}}

This is all boilerplate code and the only thing to understand is that by setting this up it will allow the !ParametersBuilder to build up the parameters on the !MockHttpServletRequest. Or, put another way, each time you call a method on the !ParametersBuilder the table will be set to that state.

With the !ParametersBuilder created the following shows how to sort the first name in ascending order and the last name in descending order.

{{{
builder.addSort("firstName", Order.ASC);
builder.addSort("lastName", Order.DESC);
}}}

If you wanted to set the page to page 2 you would do the following:
{{{
builder.setPage(2)
}}}

To add a filter you would do this:
{{{
builder.addFilter("firstName", "geo");
}}}

==== ParametersAdapter Example ====

If you are not using Spring there is a more generic way to build the parameters. The idea is you will add the parameters to a Map and then set that on the !WebContext. The reason this works is because ultimately we are using the parameters so that the Limit object can be built. So, if you use this technique you have to create the !WebContext and then create the Limit.

{{{
// First create the custom parameterMap.
Map<String, Object> parameterMap = new HashMap<String, Object>();
ParametersAdapter adapter = new ParametersAdapter(parameterMap);
ParametersBuilder builder = new ParametersBuilder(ID, adapter);

// Add some things to the filter.
builder.addFilter("fullName", "george");

// Then create the WebContext and pass in the custom paramaterMap.
MockHttpServletRequest request = new MockHttpServletRequest();
WebContext webContext = new HttpServletRequestWebContext(request);
webContext.setParameterMap(parameterMap);

// Now create the Limit.
LimitFactory limitFactory = new LimitFactoryImpl(ID, webContext);
Limit limit = limitFactory.createLimit();
}}}

=== UML Class Diagrams ===

http://extremecomponents.googlepages.com/test.png







