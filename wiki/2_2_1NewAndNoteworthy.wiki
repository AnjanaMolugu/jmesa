*Note:* See the 2.2 [2_2NewAndNoteworthy documentation] that contains the core features for the 2.2 release.

This is the bug fix report and new features listing for the 2.2.1 minor release.

== Bugs Fixed ==
The tags were incorrectly creating new table, row and column objects each iteration over the tags. The reason is the !SimpleTagSupport class creates a new object each time they are used, so the local variables were being overwritten. I refactored this back to check and pull values directly from the table on the facade. In hindsight this was a much cleaner way to do it anyway as it keeps everything in the API. This is a performance fix as nothing functionally changed.

== New Features ==
There are also a few new features of the library. I just missed getting these out on the last release and needed just a little more time to get them done.


=== !FilterMatcherMap in API ===
I added the !FilterMatcherMap to the !TableFacade interface. The !FilterMatcherMap is generally used for the tag library to set the filter matchers. By adding this to the !TableFacade it means you can use the same object for the exports. You could also use this for the general API if desired.

{{{
tableFacade.addFilterMatcherMap(new TagFilterMatcherMap());
}}}

=== !HtmlColumnsGenerator (for tag library) ===
There is a new tag called the !HtmlColumnsTag. It contains one variable called htmlColumnsGenerator.

{{{
<jmesa:htmlColumns htmlColumnsGenerator="org.jmesaweb.controller.TagHtmlColumnsGenerator"/>
}}}

It corresponds with the !HtmlColumnsGenerator interface and is used so that you can add columns on the fly.

{{{
public interface HtmlColumnsGenerator {
    public List<HtmlColumn> getColumns(HtmlComponentFactory componentFactory);
}
}}}

An example is:

{{{
public class TagHtmlColumnsGenerator extends AbstractContextSupport implements HtmlColumnsGenerator {
    public List<HtmlColumn> getColumns(HtmlComponentFactory componentFactory) {
        List<HtmlColumn> columns = new ArrayList<HtmlColumn>();

        HtmlColumn firstName = componentFactory.createColumn("name.firstName");
        firstName.setTitle("First Name");
        columns.add(firstName);

        HtmlColumn lastName = componentFactory.createColumn("name.lastName");
        lastName.setTitle("Last Name");
        columns.add(lastName);

        HtmlColumn born = componentFactory.createColumn("born");
        columns.add(born);

        return columns;
    }
}
}}}

=== !ComponentFactory in API ===
One really nice side effect of the !HtmlColumnsGenerator is I was asked if there was a similar way to create tables and exports in the API. There always was, but I abstracted it away on the facade. Now I opened up the API so that you can set tables on the facade and then use the !ComponentFactory to create tables. This technique is completely optional but may be nice in some situations, or you may decide this is a more natural way to create tables.

All you have to do is use one of the new constructors on the !TableFacadeImpl in which you do not declare the columns, and then set the table on the facade.

{{{
TableFacade tableFacade = new TableFacadeImpl(id, request, maxItems, items);

HtmlComponentFactory factory = new HtmlComponentFactory(tableFacade.getWebContext(), tableFacade.getCoreContext());

HtmlTable table = factory.createTable();

HtmlRow row = factory.createRow();
row.addColumn(factory.createColumn("name.firstName"));
row.addColumn(factory.createColumn("name.lastName"));
row.addColumn(factory.createColumn("term"));

HtmlColumn career = factory.createColumn("career");
career.setFilterable(false);
row.addColumn(career);

table.setRow(row); // be sure to set the row on the table

tableFacade.setTable(table);
}}}

Or, for the exports you could do this:

{{{
TableFacade tableFacade = new TableFacadeImpl(id, request, items); // do not need maxItems for exports
tableFacade.setExportTypes(response, "excel");

Limit limit = tableFacade.getLimit();

if (limit.isExportable()) {

    if (limit.getExport().getType().equals("excel")) {
        ExcelComponentFactory factory = new ExcelComponentFactory(tableFacade.getWebContext(), tableFacade.getCoreContext());

        Table table = factory.createTable();

        Row row = factory.createRow();
        row.addColumn(factory.createColumn("name.firstName"));
        row.addColumn(factory.createColumn("name.lastName"));
        row.addColumn(factory.createColumn("term"));
        row.addColumn(factory.createColumn("career"));

        table.setRow(row); // be sure to set the row on the table

        tableFacade.setTable(table);
    }
    
}
}}}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 