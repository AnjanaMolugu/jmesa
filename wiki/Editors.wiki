A !CellEditor is used to display the column value. You can either use the pre-canned ones included in JMesa or create something custom. Typically most tables you create will have at least one custom editor. As you will see, creating your own !CellEditor is very easy to do.

First lets go back and clarify how the !CellEditor fits into the grand scheme of things and then I will offer up some examples. If you remember a Column is a component and has attributes that represents the features of the column. A !CellRenderer is set on the Column and has attributes that represents how a column is to be displayed. The !CellEditor is set on the !CellRenderer and represents the actual column value. This keeps things very flexible and allows you to swap out one kind of functionality for another.

The !CellEditor interface looks like the following:

{{{
public interface CellEditor {
    public Object getValue(Object item, String property, int rowcount);
}
}}}

The item is the current row item from the Collection of Beans or Collections of Maps. The property is the current column property that is really a reference to an item attribute. Lastly, the rowcount is the current row. The rowcount does not take in account pagination and with each page starts the count at one. However, if you need to take in account pagination you can find the current page on the Limit object, which can be found on the !CoreContext. Although not a part of the interface, all the !CellEditors that ship with JMesa extend the !ContextSupport class, which contains access to the !CoreContext.

Like most things the best way to understand this is to see an example. The default !CellEditor is the !BasicCellEditor and simply returns the current item property.

{{{
public class BasicCellEditor extends ContextSupport implements CellEditor {
    public Object getValue(Object item, String property, int rowcount) {
        Object itemValue = null;

        try {
            itemValue = PropertyUtils.getProperty(item, property);
        } catch (Exception e) {
            e.printStackTrace();
        }

        return itemValue;
    }
}
}}}

Or, more recently, I have started just using anonymous classes to code up my editors. This makes the code very compact and easy to read.

{{{
// Using an anonymous class to implement a custom editor.
firstName.getCellRenderer().setCellEditor(new CellEditor() {
    public Object getValue(Object item, String property, int rowcount) {
        Object value = new BasicCellEditor().getValue(item, property, rowcount);
        HtmlBuilder html = new HtmlBuilder();
        html.a().href().quote().append("http://www.whitehouse.gov/history/presidents/").quote().close();
        html.append(value);
        html.aEnd();
        return html.toString();
    }
});
}}}

