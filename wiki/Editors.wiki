=== !CellEditor ===
A !CellEditor is used to display the column value. You can either use the pre-canned ones included in JMesa or create something custom. Typically most tables you create will have at least one custom editor. As you will see, creating your own !CellEditor is very easy to do.

First lets go back and clarify how the !CellEditor fits into the grand scheme of things and then I will offer up some examples. If you remember a Column is a component and has attributes that represents the features of the column. A !CellRenderer is set on the Column and has attributes that represents how a column is to be displayed. The !CellEditor is set on the !CellRenderer and represents the actual column value. This keeps things very flexible and allows you to swap out one kind of functionality for another.

The !CellEditor interface looks like the following:

{{{
public interface CellEditor {
    public Object getValue(Object item, String property, int rowcount);
}
}}}

The item is the current row item from the Collection of Beans or Collections of Maps. The property is the current column property that is really a reference to an item attribute. Lastly, the rowcount is the current row. The rowcount does not take in account pagination and with each page starts the count at one. However, if you need to take in account pagination you can find the current page on the Limit object, which can be found on the !CoreContext. 

The !CellEditors that ship with the JMesa API include the !BasicCellEditor, !DateCellEditor and the !NumberCellEditor. 

Like most things the best way to understand this is to see an example. The default !CellEditor is the !BasicCellEditor and simply returns the current item property.

{{{
public class BasicCellEditor extends AbstractContextSupport implements CellEditor {
    public Object getValue(Object item, String property, int rowcount) {
        Object itemValue = null;

        try {
            itemValue = PropertyUtils.getProperty(item, property);
        } catch (Exception e) {
            e.printStackTrace();
        }

        return itemValue;
    }
}
}}}

Or, more recently, I have started just using anonymous classes to code up my editors. This makes the code very compact and easy to read.

{{{
// Using an anonymous class to implement a custom editor.
firstName.getCellRenderer().setCellEditor(new CellEditor() {
    public Object getValue(Object item, String property, int rowcount) {
        Object value = new BasicCellEditor().getValue(item, property, rowcount);
        HtmlBuilder html = new HtmlBuilder();
        html.a().href().quote().append("http://www.whitehouse.gov/history/presidents/").quote().close();
        html.append(value);
        html.aEnd();
        return html.toString();
    }
});
}}}

The tag would look like this:
{{{
<jmesa:column cellEditor="org.jmesaweb.controller.TagCellEditor">
}}}

=== !HeaderEditor ===
As of the JMesa 2.2 release I further broke out the column header to include an editor. This works exactly like the cell editor except tailored for the header.

For instance if you wanted to have a header that displayed a checkbox you would do this:
{{{
HtmlColumn htmlColumn = (HtmlColumn)lastName;
htmlColumn.getHeaderRenderer().setHeaderEditor(new HeaderEditor() {
    public Object getValue() {
        return "<input type=\"checkbox\">";
    }
});
}}}

The tag would look like this:
{{{
<jmesa:column headerEditor="org.jmesaweb.controller.TagHeaderEditor">
}}}

=== !FilterEditor ===
As of the JMesa 2.2 release I further broke out the column filter to include an editor. This works exactly like the cell editor except tailored for the filter.

If you wanted to have a filter that displayed a select element you would do this:
{{{
HtmlColumn careerColumn = (HtmlColumn)row.getColumn("career");;
careerColumn.getFilterRenderer().setFilterEditor(new FilterEditor() {
    public Object getValue() {
        return "<select><option value=\"career\">Career</option><option value=\"lawyer\">Lawyer</option></select>";
    }
});
}}}

The tag would look like this:
{{{
<jmesa:column filterEditor="org.jmesaweb.controller.TagFilterEditor">
}}}

Keep in mind though that for this filter example you would still need to add the Javascript to interact with the Javascript Limit. If this is something you are interested in you can look at the !HtmlFilterEditor to see the default example.

*Note:* Although not a part of the interface, all the editors that ship with JMesa extend the !AbstractContextSupport class, which contains access to the !CoreContext and !WebContext. See the [SupportInterfaces support interfaces] page for more details on that.

=== UML Class Diagrams ===

==== The Editor class diagram. ====

http://extremecomponents.googlepages.com/editor.png










