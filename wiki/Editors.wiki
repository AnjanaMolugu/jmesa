A !CellEditor is used to display the column value. You can either use the pre-canned ones included in JMesa or create something custom. Typically most tables you create will have at least one custom editor. As you will see, creating your own !CellEditor is very easy to do.

First lets go back and clarify how the !CellEditor fits into the grand scheme of things and then I will offer up some examples. If you remember a Column is a component and has attributes that represents the features of the column. A !CellRenderer is set on the Column and has attributes that represents how a column is to be displayed. The !CellEditor is set on the !CellRenderer and represents the actual column value. This keeps things very flexible and allows you to swap out one kind of functionality for another.

The !CellEditor interface looks like the following:

{{{
public interface CellEditor {
    public Object getValue(Object item, String property, int rowcount);
}
}}}

The item is the current row item from the Collection of Beans or Collections of Maps. The property is the current column property that is really a reference to an item attribute. Lastly, the rowcount is the current row. The rowcount does not take in account pagination and with each page starts the count at one. However, if you need to take in account pagination you can find the current page on the Limit object, which can be found on the !CoreContext. Although not a part of the interface, all the !CellEditors that ship with JMesa extend the !ContextSupport class, which contains access to the !CoreContext.

Like most things the best way to understand this is to see an example. The default !CellEditor is the !BasicCellEditor and simply returns the current item property.

{{{
public class BasicCellEditor extends ContextSupport implements CellEditor {
    public Object getValue(Object item, String property, int rowcount) {
        Object itemValue = null;

        try {
            itemValue = PropertyUtils.getProperty(item, property);
        } catch (Exception e) {
            e.printStackTrace();
        }

        return itemValue;
    }
}
}}}

It should be easy to see that we are just getting and returning the current item property. Typically you would not instantiate a !BasicCellEditor yourself (although you could), but you would just use one of the factory classes instead. 

{{{
HtmlComponentFactory factory = new HtmlComponentFactory(webContext, coreContext);
CellEditor editor = factory.createBasicCellEditor();

// this is a convenience method to create a column, along with all the default renderers
HtmlColumn lastName = factory.createColumn("name.lastName", editor);
}}}

Using the factory allows you to easily and quickly create and use an editor. Lets see what it takes to create a custom editor. The following example is interesting because it uses the decorator pattern to wrap any kind of editor with a link.

{{{
private static class PresidentsLinkEditor implements CellEditor {
    CellEditor cellEditor;

    public PresidentsLinkEditor(CellEditor cellEditor) {
        this.cellEditor = cellEditor;
    }

    public Object getValue(Object item, String property, int rowcount) {
        Object value = cellEditor.getValue(item, property, rowcount);
        HtmlBuilder html = new HtmlBuilder();
        html.a().href().quote().append("http://www.whitehouse.gov/history/presidents/").quote().close();
        html.append(value);
        html.aEnd();
        return html.toString();
    }
}
}}}








