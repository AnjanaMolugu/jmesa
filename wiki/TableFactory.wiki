To make building JMesa tables easier you can use either the TableFactory, or the [ComponentFactory]. The lower level factory is the [ComponentFactory] and will be demonstrated here. I find using a [ComponentFactory] most useful when building HTML tables that are more custom. For exports I would recommend using the TableFactory because they typically have pretty simple requirements. For more information about components, renderers and editors first read the [View view] overview.

==== HTML View ====

The following is as an example of what an HTML table would look like: 
{{{
public Object htmlTable(WebContext webContext, CoreContext coreContext) {
    HtmlTableFactory tableFactory = new HtmlTableFactory(webContext, coreContext);

    HtmlTable table = tableFactory.createTable("firstName", "lastName", "term", "career");
    table.setCaption("Presidents");
    table.getTableRenderer().setWidth("600px;");

    CellEditor editor = new PresidentsLinkEditor(new BasicCellEditor());
    table.getRow().getColumn("firstName").getCellRenderer().setCellEditor(editor);

    ToolbarFactory toolbarFactory = new ToolbarFactoryImpl(table, webContext, coreContext, "csv");
    Toolbar toolbar = toolbarFactory.createToolbar();
    View view = new HtmlView(table, toolbar, coreContext);

    return view.render();
}
}}}

Notice the use of the JDK1.5 varargs in the  createTable() method parameters! 

The !PresidentsLinkEditor is an implementation of the !CellEditor and shows what it means to compose the column renderer with a custom cell editor. Because the !TableFactory creates the whole table at once you must first find the column and then grab the renderer. 

{{{
private static class PresidentsLinkEditor implements CellEditor {
    CellEditor cellEditor;

    public PresidentsLinkEditor(CellEditor cellEditor) {
        this.cellEditor = cellEditor;
    }

    public Object getValue(Object item, String property, int rowcount) {
        Object value = cellEditor.getValue(item, property, rowcount);
        HtmlBuilder html = new HtmlBuilder();
        html.a().href().quote().append("http://www.whitehouse.gov/history/presidents/").quote().close();
        html.append(value);
        html.aEnd();
        return html.toString();
    }
}
}}}

==== CSV Export View ====

The following is as an example of what a CSV export table would look like:
{{{
public void csvTable(WebContext webContext, CoreContext coreContext, HttpServletResponse response)
        throws Exception {
    TableFactory tableFactory = new CsvTableFactory(webContext, coreContext);
    Table table = tableFactory.createTable("firstName", "lastName", "term", "career");
    View view = new CsvView(table, coreContext);
    ViewExporter exporter = new CsvViewExporter(view, "presidents.txt", response);
    exporter.export();
}
}}}

The additional step here is in using the !ViewExporter. The !ViewExporter is responsible for calling the render() method on the View and then exporting it to the response when the export() method is invoked.




