*NOTE: I no longer recommend building tables this way.* The preferred way to build a table is using the [TableFacade] or using the [Tags tag library]. The facade does use the following methodology, but this is considered a low level coding technique that should only be used for JMesa developers. It should not be necessary to use this technique to build your tables.

To make building JMesa tables easier you can use either the !TableFactory, or the [ComponentFactory]. The highest level factory is the !TableFactory and will be demonstrated here. I find using a !TableFactory most useful when building exports as most exports are pretty generic. The !TableFactory is also useful for HTML tables if you want to have the table created initially, and then can be customized by swapping out the default functionality for something else. For more information about components, renderers and editors first read the [View view] overview.

==== HTML Example ====

The following is as an example of what an HTML table would look like: 
{{{
public Object htmlTable(WebContext webContext, CoreContext coreContext) {
    HtmlTableFactory tableFactory = new HtmlTableFactory(webContext, coreContext);

    HtmlTable table = tableFactory.createTable("firstName", "lastName", "term", "career");
    table.setCaption("Presidents");
    table.getTableRenderer().setWidth("600px;");

    CellEditor editor = new PresidentsLinkEditor(new BasicCellEditor());
    table.getRow().getColumn("firstName").getCellRenderer().setCellEditor(editor);

    ToolbarFactory toolbarFactory = new ToolbarFactoryImpl(table, webContext, coreContext, "csv");
    Toolbar toolbar = toolbarFactory.createToolbar();
    View view = new HtmlView(table, toolbar, coreContext);

    return view.render();
}
}}}

Notice the use of the JDK1.5 varargs in the  createTable() method parameters! 

The !PresidentsLinkEditor is an implementation of the !CellEditor and shows what it means to compose the column renderer with a custom cell editor. Because the !TableFactory creates the whole table at once you must first find the column and then grab the renderer. 

{{{
/**
 * Create a link for the first name column. Using the decorator pattern so
 * that can wrap any kind of editor with a link.
 */
private static class PresidentsLinkEditor implements CellEditor {
    CellEditor cellEditor;

    public PresidentsLinkEditor(CellEditor cellEditor) {
        this.cellEditor = cellEditor;
    }

    public Object getValue(Object item, String property, int rowcount) {
        Object value = cellEditor.getValue(item, property, rowcount);
        HtmlBuilder html = new HtmlBuilder();
        html.a().href().quote().append("http://www.whitehouse.gov/history/presidents/").quote().close();
        html.append(value);
        html.aEnd();
        return html.toString();
    }
}
}}}

==== CSV Export Example ====

The following is as an example of what a CSV export table would look like:
{{{
public void csvTable(WebContext webContext, CoreContext coreContext, HttpServletResponse response)
        throws Exception {
    TableFactory tableFactory = new CsvTableFactory(webContext, coreContext);
    Table table = tableFactory.createTable("firstName", "lastName", "term", "career");
    View view = new CsvView(table, coreContext);
    ViewExporter exporter = new CsvViewExporter(view, "presidents.txt", response);
    exporter.export();
}
}}}

The additional step here is in using the !ViewExporter. The !ViewExporter is responsible for calling the render() method on the View and then exporting it to the response when the export() method is invoked.





